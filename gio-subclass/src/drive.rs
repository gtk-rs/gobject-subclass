// This file was generated by gir (https://github.com/gtk-rs/gir @ a3d21e2+)
// from gir-files (https://github.com/gtk-rs/gir-files @ b215ee8+)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]

extern crate libc;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

use Volume;
use ffi;
use glib;
use glib::object::Downcast;
use glib::object::IsA;
use glib::signal::SignalHandlerId;
use glib::signal::connect;
use glib::translate::*;
use glib_ffi;
use gobject_ffi;
use std::boxed::Box as Box_;
use std::mem;
use std::mem::transmute;
use std::ptr;


pub trait DriveImpl: AnyImpl + 'static {

    fn can_eject(&self, drive: &T) -> bool;

    fn can_poll_for_media(&self, drive: &T) -> bool;

    fn can_start(&self, drive: &T) -> bool;

    fn can_start_degraded(&self, drive: &T) -> bool;

    fn can_stop(&self, drive: &T) -> bool;

    fn changed(&self, drive: &T);

    fn disconnected(&self, drive: &T);

    fn eject(&self, drive: &T, flags: /*Ignored*/MountUnmountFlags, cancellable: /*Ignored*/Option<&Cancellable>, callback: AsyncReadyCallback);

    fn eject_button(&self, drive: &T);

    fn eject_finish(&self, drive: &T, result: /*Ignored*/&AsyncResult) -> Result<(), Error>;

    fn eject_with_operation(&self, drive: &T, flags: /*Ignored*/MountUnmountFlags, mount_operation: /*Ignored*/Option<&MountOperation>, cancellable: /*Ignored*/Option<&Cancellable>, callback: AsyncReadyCallback);

    fn eject_with_operation_finish(&self, drive: &T, result: /*Ignored*/&AsyncResult) -> Result<(), Error>;

    fn enumerate_identifiers(&self, drive: &T) -> Vec<String>;

    fn get_icon(&self, drive: &T) -> /*Ignored*/Option<Icon>;

    fn get_identifier(&self, drive: &T, kind: &str) -> Option<String>;

    fn get_name(&self, drive: &T) -> Option<String>;

    fn get_sort_key(&self, drive: &T) -> Option<String>;

    fn get_start_stop_type(&self, drive: &T) -> /*Ignored*/DriveStartStopType;

    fn get_symbolic_icon(&self, drive: &T) -> /*Ignored*/Option<Icon>;

    fn get_volumes(&self, drive: &T) -> Vec<Volume>;

    fn has_media(&self, drive: &T) -> bool;

    fn has_volumes(&self, drive: &T) -> bool;

    fn is_media_check_automatic(&self, drive: &T) -> bool;

    fn is_media_removable(&self, drive: &T) -> bool;

    fn is_removable(&self, drive: &T) -> bool;

    fn poll_for_media(&self, drive: &T, cancellable: /*Ignored*/Option<&Cancellable>, callback: AsyncReadyCallback);

    fn poll_for_media_finish(&self, drive: &T, result: /*Ignored*/&AsyncResult) -> Result<(), Error>;

    fn start(&self, drive: &T, flags: /*Ignored*/DriveStartFlags, mount_operation: /*Ignored*/Option<&MountOperation>, cancellable: /*Ignored*/Option<&Cancellable>, callback: AsyncReadyCallback);

    fn start_finish(&self, drive: &T, result: /*Ignored*/&AsyncResult) -> Result<(), Error>;

    fn stop(&self, drive: &T, flags: /*Ignored*/MountUnmountFlags, mount_operation: /*Ignored*/Option<&MountOperation>, cancellable: /*Ignored*/Option<&Cancellable>, callback: AsyncReadyCallback);

    fn stop_button(&self, drive: &T);

    fn stop_finish(&self, drive: &T, result: /*Ignored*/&AsyncResult) -> Result<(), Error>;

}

any_impl!(DriveImpl);

pub trait DriveImplStatic<T: ObjectType>: 'static {
    fn get_impl<'a>(&self, imp: &'a T::ImplType) -> &'a DriveImpl;
}

struct DriveStatic<T: ObjectType>{
    imp_static: *const DriveImplStatic<T>
}

unsafe extern "C" fn drive_can_eject<T: >
(ptr: *mut GDrive) -> gboolean
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.can_eject()
}

unsafe extern "C" fn drive_can_poll_for_media<T: >
(ptr: *mut GDrive) -> gboolean
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.can_poll_for_media()
}

unsafe extern "C" fn drive_can_start<T: >
(ptr: *mut GDrive) -> gboolean
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.can_start()
}

unsafe extern "C" fn drive_can_start_degraded<T: >
(ptr: *mut GDrive) -> gboolean
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.can_start_degraded()
}

unsafe extern "C" fn drive_can_stop<T: >
(ptr: *mut GDrive) -> gboolean
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.can_stop()
}

unsafe extern "C" fn drive_changed<T: >
(ptr: *mut GDrive)
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.changed()
}

unsafe extern "C" fn drive_disconnected<T: >
(ptr: *mut GDrive)
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.disconnected()
}

unsafe extern "C" fn drive_eject<T: >
(ptr: *mut GDrive, flags: GMountUnmountFlags, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer)
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.eject()
}

unsafe extern "C" fn drive_eject_button<T: >
(ptr: *mut GDrive)
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.eject_button()
}

unsafe extern "C" fn drive_eject_finish<T: >
(ptr: *mut GDrive, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.eject_finish()
}

unsafe extern "C" fn drive_eject_with_operation<T: >
(ptr: *mut GDrive, flags: GMountUnmountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer)
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.eject_with_operation()
}

unsafe extern "C" fn drive_eject_with_operation_finish<T: >
(ptr: *mut GDrive, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.eject_with_operation_finish()
}

unsafe extern "C" fn drive_enumerate_identifiers<T: >
(ptr: *mut GDrive) -> *mut *mut c_char
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.enumerate_identifiers()
}

unsafe extern "C" fn drive_get_icon<T: >
(ptr: *mut GDrive) -> *mut GIcon
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_icon()
}

unsafe extern "C" fn drive_get_identifier<T: >
(ptr: *mut GDrive, kind: *const c_char) -> *mut c_char
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_identifier()
}

unsafe extern "C" fn drive_get_name<T: >
(ptr: *mut GDrive) -> *mut c_char
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_name()
}

unsafe extern "C" fn drive_get_sort_key<T: >
(ptr: *mut GDrive) -> *const c_char
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_sort_key()
}

unsafe extern "C" fn drive_get_start_stop_type<T: >
(ptr: *mut GDrive) -> GDriveStartStopType
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_start_stop_type()
}

unsafe extern "C" fn drive_get_symbolic_icon<T: >
(ptr: *mut GDrive) -> *mut GIcon
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_symbolic_icon()
}

unsafe extern "C" fn drive_get_volumes<T: >
(ptr: *mut GDrive) -> *mut glib::GList
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_volumes()
}

unsafe extern "C" fn drive_has_media<T: >
(ptr: *mut GDrive) -> gboolean
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.has_media()
}

unsafe extern "C" fn drive_has_volumes<T: >
(ptr: *mut GDrive) -> gboolean
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.has_volumes()
}

unsafe extern "C" fn drive_is_media_check_automatic<T: >
(ptr: *mut GDrive) -> gboolean
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.is_media_check_automatic()
}

unsafe extern "C" fn drive_is_media_removable<T: >
(ptr: *mut GDrive) -> gboolean
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.is_media_removable()
}

unsafe extern "C" fn drive_is_removable<T: >
(ptr: *mut GDrive) -> gboolean
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.is_removable()
}

unsafe extern "C" fn drive_poll_for_media<T: >
(ptr: *mut GDrive, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer)
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.poll_for_media()
}

unsafe extern "C" fn drive_poll_for_media_finish<T: >
(ptr: *mut GDrive, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.poll_for_media_finish()
}

unsafe extern "C" fn drive_start<T: >
(ptr: *mut GDrive, flags: GDriveStartFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer)
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.start()
}

unsafe extern "C" fn drive_start_finish<T: >
(ptr: *mut GDrive, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.start_finish()
}

unsafe extern "C" fn drive_stop<T: >
(ptr: *mut GDrive, flags: GMountUnmountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer)
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.stop()
}

unsafe extern "C" fn drive_stop_button<T: >
(ptr: *mut GDrive)
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.stop_button()
}

unsafe extern "C" fn drive_stop_finish<T: >
(ptr: *mut GDrive, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean
where
    T::ImplType: DriveImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type())
                                     as *const DriveStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.stop_finish()
}

unsafe extern "C" fn drive_init<T: ObjectType>(
    iface: glib_ffi::gpointer,
    iface_data: glib_ffi::gpointer
) {
    callback_guard!();
    let drive_iface = &mut *(iface as *mut ffi::);
    let iface_type = (*(iface as *const gobject_ffi::GTypeInterface)).g_type;
    let type_ = (*(iface as *const gobject_ffi::GTypeInterface)).g_instance_type;
    let klass = &mut *(gobject_ffi::g_type_class_ref(type_) as *mut ClassStruct<T>);
    let interfaces_static = &mut *(klass.interfaces_static as *mut Vec<_>);
    interfaces_static.push((iface_type, iface_data))
    drive_iface.can_eject = Some(drive_can_eject::<T>);
    drive_iface.can_poll_for_media = Some(drive_can_poll_for_media::<T>);
    drive_iface.can_start = Some(drive_can_start::<T>);
    drive_iface.can_start_degraded = Some(drive_can_start_degraded::<T>);
    drive_iface.can_stop = Some(drive_can_stop::<T>);
    drive_iface.changed = Some(drive_changed::<T>);
    drive_iface.disconnected = Some(drive_disconnected::<T>);
    drive_iface.eject = Some(drive_eject::<T>);
    drive_iface.eject_button = Some(drive_eject_button::<T>);
    drive_iface.eject_finish = Some(drive_eject_finish::<T>);
    drive_iface.eject_with_operation = Some(drive_eject_with_operation::<T>);
    drive_iface.eject_with_operation_finish = Some(drive_eject_with_operation_finish::<T>);
    drive_iface.enumerate_identifiers = Some(drive_enumerate_identifiers::<T>);
    drive_iface.get_icon = Some(drive_get_icon::<T>);
    drive_iface.get_identifier = Some(drive_get_identifier::<T>);
    drive_iface.get_name = Some(drive_get_name::<T>);
    drive_iface.get_sort_key = Some(drive_get_sort_key::<T>);
    drive_iface.get_start_stop_type = Some(drive_get_start_stop_type::<T>);
    drive_iface.get_symbolic_icon = Some(drive_get_symbolic_icon::<T>);
    drive_iface.get_volumes = Some(drive_get_volumes::<T>);
    drive_iface.has_media = Some(drive_has_media::<T>);
    drive_iface.has_volumes = Some(drive_has_volumes::<T>);
    drive_iface.is_media_check_automatic = Some(drive_is_media_check_automatic::<T>);
    drive_iface.is_media_removable = Some(drive_is_media_removable::<T>);
    drive_iface.is_removable = Some(drive_is_removable::<T>);
    drive_iface.poll_for_media = Some(drive_poll_for_media::<T>);
    drive_iface.poll_for_media_finish = Some(drive_poll_for_media_finish::<T>);
    drive_iface.start = Some(drive_start::<T>);
    drive_iface.start_finish = Some(drive_start_finish::<T>);
    drive_iface.stop = Some(drive_stop::<T>);
    drive_iface.stop_button = Some(drive_stop_button::<T>);
    drive_iface.stop_finish = Some(drive_stop_finish::<T>);
}

unsafe extern "C" fn drive_get_type<T: ObjectType>(
    type_: glib_ffi::GType
) -> glib::Type {
    callback_guard!();
    let klass = gobject_ffi::g_type_class_peek(type_);
    let klass = &*(klass as *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::drive_get_type()) as *const DriveStatic<T>;
    (*(*interface_static).imp_static).get_type().to_glib()
}
