// This file was generated by gir (https://github.com/gtk-rs/gir @ a3d21e2+)
// from gir-files (https://github.com/gtk-rs/gir-files @ b215ee8+)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]

extern crate libc;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

use AppInfo;
use ffi;
use glib;
#[cfg(any(feature = "v2_36", feature = "dox"))]
use glib::object::Downcast;
use glib::object::IsA;
#[cfg(any(feature = "v2_36", feature = "dox"))]
use glib::signal::SignalHandlerId;
#[cfg(any(feature = "v2_36", feature = "dox"))]
use glib::signal::connect;
use glib::translate::*;
use glib_ffi;
use gobject_ffi;
#[cfg(any(feature = "v2_36", feature = "dox"))]
use libc;
use std;
#[cfg(any(feature = "v2_36", feature = "dox"))]
use std::boxed::Box as Box_;
use std::mem;
#[cfg(any(feature = "v2_36", feature = "dox"))]
use std::mem::transmute;
use std::ptr;


pub trait AppLaunchContextImpl<T: AppLaunchContextBase>: ObjectImpl<T> + AnyImpl + 'static {

    fn get_display(&self, context: &T, info: &AppInfo, files: /*Ignored*/&[File]) -> Option<String>{
        context.parent_get_display(info, files)
    }

    fn get_startup_notify_id(&self, context: &T, info: &AppInfo, files: /*Ignored*/&[File]) -> Option<String>{
        context.parent_get_startup_notify_id(info, files)
    }

    fn launch_failed(&self, context: &T, startup_notify_id: &str){
        context.parent_launch_failed(startup_notify_id)
    }

    fn launched(&self, context: &T, info: &AppInfo, platform_data: &glib::Variant){
        context.parent_launched(info, platform_data)
    }

}

pub trait AppLaunchContextImplExt<T> {}

}
impl<S: AppLaunchContextImpl<T>, T: ObjectType >> AppLaunchContextImplExt<T> for S {}

any_impl!(AppLaunchContextBase, AppLaunchContextImpl);

pub unsafe trait AppLaunchContextBase: ObjectType {

    fn parent_get_display(&self, info: &AppInfo, files: /*Ignored*/&[File]) -> Option<String>{
        unsafe {
            let klass = self.get_class();
            let parent_klass = (*klass).get_parent_class() as *const ffi::GAppLaunchContextClass;
            (*parent_klass)
            .get_display
            .map(|f|{ from_glib_full(f(self.to_glib_none().0,info.to_glib_none().0,files.to_glib_none().0)) })
            .unwrap_or(())
        }
    }

    fn parent_get_startup_notify_id(&self, info: &AppInfo, files: /*Ignored*/&[File]) -> Option<String>{
        unsafe {
            let klass = self.get_class();
            let parent_klass = (*klass).get_parent_class() as *const ffi::GAppLaunchContextClass;
            (*parent_klass)
            .get_startup_notify_id
            .map(|f|{ from_glib_full(f(self.to_glib_none().0,info.to_glib_none().0,files.to_glib_none().0)) })
            .unwrap_or(())
        }
    }

    fn parent_launch_failed(&self, startup_notify_id: &str){
        unsafe {
            let klass = self.get_class();
            let parent_klass = (*klass).get_parent_class() as *const ffi::GAppLaunchContextClass;
            (*parent_klass)
            .launch_failed
            .map(|f|{ f(self.to_glib_none().0,startup_notify_id.to_glib_none().0); })
            .unwrap_or(())
        }
    }

    fn parent_launched(&self, info: &AppInfo, platform_data: &glib::Variant){
        unsafe {
            let klass = self.get_class();
            let parent_klass = (*klass).get_parent_class() as *const ffi::GAppLaunchContextClass;
            (*parent_klass)
            .launched
            .map(|f|{ f(self.to_glib_none().0,info.to_glib_none().0,platform_data.to_glib_none().0); })
            .unwrap_or(())
        }
    }

}

pub unsafe trait AppLaunchContextClassExt<T: AppLaunchContextBase>
where
    T::ImplType: AppLaunchContextImpl<T>{

    fn override_vfuncs(&mut self, _: &ClassInitToken){
        unsafe {
            let klass = &mut *(self as *const Self as *mut ffi::GAppLaunchContextClass);
            klass.get_display = Some(applaunchcontext_get_display::<T>);
            klass.get_startup_notify_id = Some(applaunchcontext_get_startup_notify_id::<T>);
            klass.launch_failed = Some(applaunchcontext_launch_failed::<T>);
            klass.launched = Some(applaunchcontext_launched::<T>);
        }
    }

}

glib_wrapper! {

    pub struct AppLaunchContext(Object<InstanceStruct<AppLaunchContext>>)    ;
    match fn { 
         get_type => || get_type::<AppLaunchContext>(),
     }

}

unsafe impl<T: ObjectType > AppLaunchContextBase for T {}

pub type AppLaunchContextClass = ClassStruct<AppLaunchContext>;

// FIXME: Boilerplate

// FIXME: Boilerplate

#[macro_export]
macro_rules! box_applaunchcontext_impl(
    ($name:ident) => {
        box_object_impl!($name);
        impl<T: $crate::app_launch_context::AppLaunchContextBase> $crate::app_launch_context::AppLaunchContextImpl<T> for Box<$name<T>>{

            fn get_display(&self, context: &T, info: &AppInfo, files: /*Ignored*/&[File]) -> Option<String>{
                let imp: &$name<T> = self.as_ref();
                imp.get_display(info, files)
            }

            fn get_startup_notify_id(&self, context: &T, info: &AppInfo, files: /*Ignored*/&[File]) -> Option<String>{
                let imp: &$name<T> = self.as_ref();
                imp.get_startup_notify_id(info, files)
            }

            fn launch_failed(&self, context: &T, startup_notify_id: &str){
                let imp: &$name<T> = self.as_ref();
                imp.launch_failed(startup_notify_id)
            }

            fn launched(&self, context: &T, info: &AppInfo, platform_data: &glib::Variant){
                let imp: &$name<T> = self.as_ref();
                imp.launched(info, platform_data)
            }
        }
    }
);

impl ObjectType for AppLaunchContext{
    const NAME: &'static str = "RsGio.AppLaunchContext";
    type ImplType = Box<AppLaunchContextImpl<Self>>;
    type InstanceStructType = InstanceStruct<Self>;
    fn class_init(token: &ClassInitToken, klass: &mut AppLaunchContextClass) {
        ObjectClassExt::override_vfuncs(klass, token);
    }
    object_type_fns!();
}

unsafe extern "C" fn applaunchcontext_get_display<T: AppLaunchContextBase>
(ptr: *mut GAppLaunchContext, info: *mut GAppInfo, files: *mut glib::GList) -> *mut c_char
where
    T::ImplType: AppLaunchContextImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let applaunchcontext = &*(ptr as *mut T::InstanceStructType);
    let wrap: T = from_glib_borrow(ptr as *mut T::InstanceStructType);
    let imp = applaunchcontext.get_impl();
    imp.get_display()
}

unsafe extern "C" fn applaunchcontext_get_startup_notify_id<T: AppLaunchContextBase>
(ptr: *mut GAppLaunchContext, info: *mut GAppInfo, files: *mut glib::GList) -> *mut c_char
where
    T::ImplType: AppLaunchContextImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let applaunchcontext = &*(ptr as *mut T::InstanceStructType);
    let wrap: T = from_glib_borrow(ptr as *mut T::InstanceStructType);
    let imp = applaunchcontext.get_impl();
    imp.get_startup_notify_id()
}

unsafe extern "C" fn applaunchcontext_launch_failed<T: AppLaunchContextBase>
(ptr: *mut GAppLaunchContext, startup_notify_id: *const c_char)
where
    T::ImplType: AppLaunchContextImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let applaunchcontext = &*(ptr as *mut T::InstanceStructType);
    let wrap: T = from_glib_borrow(ptr as *mut T::InstanceStructType);
    let imp = applaunchcontext.get_impl();
    imp.launch_failed()
}

unsafe extern "C" fn applaunchcontext_launched<T: AppLaunchContextBase>
(ptr: *mut GAppLaunchContext, info: *mut GAppInfo, platform_data: *mut glib::GVariant)
where
    T::ImplType: AppLaunchContextImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let applaunchcontext = &*(ptr as *mut T::InstanceStructType);
    let wrap: T = from_glib_borrow(ptr as *mut T::InstanceStructType);
    let imp = applaunchcontext.get_impl();
    imp.launched()
}
