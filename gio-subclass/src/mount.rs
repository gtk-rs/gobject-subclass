// This file was generated by gir (https://github.com/gtk-rs/gir @ a3d21e2+)
// from gir-files (https://github.com/gtk-rs/gir-files @ b215ee8+)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]

extern crate libc;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

use Drive;
use Volume;
use ffi;
use glib;
use glib::object::Downcast;
use glib::object::IsA;
use glib::signal::SignalHandlerId;
use glib::signal::connect;
use glib::translate::*;
use glib_ffi;
use gobject_ffi;
use std::boxed::Box as Box_;
use std::mem;
use std::mem::transmute;
use std::ptr;


pub trait MountImpl: AnyImpl + 'static {

    fn can_eject(&self, mount: &T) -> bool;

    fn can_unmount(&self, mount: &T) -> bool;

    fn changed(&self, mount: &T);

    fn eject(&self, mount: &T, flags: /*Ignored*/MountUnmountFlags, cancellable: /*Ignored*/Option<&Cancellable>, callback: AsyncReadyCallback);

    fn eject_finish(&self, mount: &T, result: /*Ignored*/&AsyncResult) -> Result<(), Error>;

    fn eject_with_operation(&self, mount: &T, flags: /*Ignored*/MountUnmountFlags, mount_operation: /*Ignored*/Option<&MountOperation>, cancellable: /*Ignored*/Option<&Cancellable>, callback: AsyncReadyCallback);

    fn eject_with_operation_finish(&self, mount: &T, result: /*Ignored*/&AsyncResult) -> Result<(), Error>;

    fn get_default_location(&self, mount: &T) -> /*Ignored*/Option<File>;

    fn get_drive(&self, mount: &T) -> Option<Drive>;

    fn get_icon(&self, mount: &T) -> /*Ignored*/Option<Icon>;

    fn get_name(&self, mount: &T) -> Option<String>;

    fn get_root(&self, mount: &T) -> /*Ignored*/Option<File>;

    fn get_sort_key(&self, mount: &T) -> Option<String>;

    fn get_symbolic_icon(&self, mount: &T) -> /*Ignored*/Option<Icon>;

    fn get_uuid(&self, mount: &T) -> Option<String>;

    fn get_volume(&self, mount: &T) -> Option<Volume>;

    fn guess_content_type(&self, mount: &T, force_rescan: bool, cancellable: /*Ignored*/Option<&Cancellable>, callback: AsyncReadyCallback);

    fn guess_content_type_finish(&self, mount: &T, result: /*Ignored*/&AsyncResult) -> Result<Vec<String>, Error>;

    fn guess_content_type_sync(&self, mount: &T, force_rescan: bool, cancellable: /*Ignored*/Option<&Cancellable>) -> Result<Vec<String>, Error>;

    fn pre_unmount(&self, mount: &T);

    fn remount(&self, mount: &T, flags: /*Ignored*/MountMountFlags, mount_operation: /*Ignored*/Option<&MountOperation>, cancellable: /*Ignored*/Option<&Cancellable>, callback: AsyncReadyCallback);

    fn remount_finish(&self, mount: &T, result: /*Ignored*/&AsyncResult) -> Result<(), Error>;

    fn unmount(&self, mount: &T, flags: /*Ignored*/MountUnmountFlags, cancellable: /*Ignored*/Option<&Cancellable>, callback: AsyncReadyCallback);

    fn unmount_finish(&self, mount: &T, result: /*Ignored*/&AsyncResult) -> Result<(), Error>;

    fn unmount_with_operation(&self, mount: &T, flags: /*Ignored*/MountUnmountFlags, mount_operation: /*Ignored*/Option<&MountOperation>, cancellable: /*Ignored*/Option<&Cancellable>, callback: AsyncReadyCallback);

    fn unmount_with_operation_finish(&self, mount: &T, result: /*Ignored*/&AsyncResult) -> Result<(), Error>;

    fn unmounted(&self, mount: &T);

}

any_impl!(MountImpl);

pub trait MountImplStatic<T: ObjectType>: 'static {
    fn get_impl<'a>(&self, imp: &'a T::ImplType) -> &'a MountImpl;
}

struct MountStatic<T: ObjectType>{
    imp_static: *const MountImplStatic<T>
}

unsafe extern "C" fn mount_can_eject<T: >
(ptr: *mut GMount) -> gboolean
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.can_eject()
}

unsafe extern "C" fn mount_can_unmount<T: >
(ptr: *mut GMount) -> gboolean
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.can_unmount()
}

unsafe extern "C" fn mount_changed<T: >
(ptr: *mut GMount)
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.changed()
}

unsafe extern "C" fn mount_eject<T: >
(ptr: *mut GMount, flags: GMountUnmountFlags, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer)
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.eject()
}

unsafe extern "C" fn mount_eject_finish<T: >
(ptr: *mut GMount, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.eject_finish()
}

unsafe extern "C" fn mount_eject_with_operation<T: >
(ptr: *mut GMount, flags: GMountUnmountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer)
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.eject_with_operation()
}

unsafe extern "C" fn mount_eject_with_operation_finish<T: >
(ptr: *mut GMount, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.eject_with_operation_finish()
}

unsafe extern "C" fn mount_get_default_location<T: >
(ptr: *mut GMount) -> *mut GFile
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_default_location()
}

unsafe extern "C" fn mount_get_drive<T: >
(ptr: *mut GMount) -> *mut GDrive
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_drive()
}

unsafe extern "C" fn mount_get_icon<T: >
(ptr: *mut GMount) -> *mut GIcon
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_icon()
}

unsafe extern "C" fn mount_get_name<T: >
(ptr: *mut GMount) -> *mut c_char
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_name()
}

unsafe extern "C" fn mount_get_root<T: >
(ptr: *mut GMount) -> *mut GFile
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_root()
}

unsafe extern "C" fn mount_get_sort_key<T: >
(ptr: *mut GMount) -> *const c_char
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_sort_key()
}

unsafe extern "C" fn mount_get_symbolic_icon<T: >
(ptr: *mut GMount) -> *mut GIcon
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_symbolic_icon()
}

unsafe extern "C" fn mount_get_uuid<T: >
(ptr: *mut GMount) -> *mut c_char
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_uuid()
}

unsafe extern "C" fn mount_get_volume<T: >
(ptr: *mut GMount) -> *mut GVolume
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_volume()
}

unsafe extern "C" fn mount_guess_content_type<T: >
(ptr: *mut GMount, force_rescan: gboolean, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer)
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.guess_content_type()
}

unsafe extern "C" fn mount_guess_content_type_finish<T: >
(ptr: *mut GMount, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> *mut *mut c_char
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.guess_content_type_finish()
}

unsafe extern "C" fn mount_guess_content_type_sync<T: >
(ptr: *mut GMount, force_rescan: gboolean, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> *mut *mut c_char
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.guess_content_type_sync()
}

unsafe extern "C" fn mount_pre_unmount<T: >
(ptr: *mut GMount)
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.pre_unmount()
}

unsafe extern "C" fn mount_remount<T: >
(ptr: *mut GMount, flags: GMountMountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer)
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.remount()
}

unsafe extern "C" fn mount_remount_finish<T: >
(ptr: *mut GMount, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.remount_finish()
}

unsafe extern "C" fn mount_unmount<T: >
(ptr: *mut GMount, flags: GMountUnmountFlags, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer)
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.unmount()
}

unsafe extern "C" fn mount_unmount_finish<T: >
(ptr: *mut GMount, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.unmount_finish()
}

unsafe extern "C" fn mount_unmount_with_operation<T: >
(ptr: *mut GMount, flags: GMountUnmountFlags, mount_operation: *mut GMountOperation, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer)
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.unmount_with_operation()
}

unsafe extern "C" fn mount_unmount_with_operation_finish<T: >
(ptr: *mut GMount, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.unmount_with_operation_finish()
}

unsafe extern "C" fn mount_unmounted<T: >
(ptr: *mut GMount)
where
    T::ImplType: MountImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type())
                                     as *const MountStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.unmounted()
}

unsafe extern "C" fn mount_init<T: ObjectType>(
    iface: glib_ffi::gpointer,
    iface_data: glib_ffi::gpointer
) {
    callback_guard!();
    let mount_iface = &mut *(iface as *mut ffi::);
    let iface_type = (*(iface as *const gobject_ffi::GTypeInterface)).g_type;
    let type_ = (*(iface as *const gobject_ffi::GTypeInterface)).g_instance_type;
    let klass = &mut *(gobject_ffi::g_type_class_ref(type_) as *mut ClassStruct<T>);
    let interfaces_static = &mut *(klass.interfaces_static as *mut Vec<_>);
    interfaces_static.push((iface_type, iface_data))
    mount_iface.can_eject = Some(mount_can_eject::<T>);
    mount_iface.can_unmount = Some(mount_can_unmount::<T>);
    mount_iface.changed = Some(mount_changed::<T>);
    mount_iface.eject = Some(mount_eject::<T>);
    mount_iface.eject_finish = Some(mount_eject_finish::<T>);
    mount_iface.eject_with_operation = Some(mount_eject_with_operation::<T>);
    mount_iface.eject_with_operation_finish = Some(mount_eject_with_operation_finish::<T>);
    mount_iface.get_default_location = Some(mount_get_default_location::<T>);
    mount_iface.get_drive = Some(mount_get_drive::<T>);
    mount_iface.get_icon = Some(mount_get_icon::<T>);
    mount_iface.get_name = Some(mount_get_name::<T>);
    mount_iface.get_root = Some(mount_get_root::<T>);
    mount_iface.get_sort_key = Some(mount_get_sort_key::<T>);
    mount_iface.get_symbolic_icon = Some(mount_get_symbolic_icon::<T>);
    mount_iface.get_uuid = Some(mount_get_uuid::<T>);
    mount_iface.get_volume = Some(mount_get_volume::<T>);
    mount_iface.guess_content_type = Some(mount_guess_content_type::<T>);
    mount_iface.guess_content_type_finish = Some(mount_guess_content_type_finish::<T>);
    mount_iface.guess_content_type_sync = Some(mount_guess_content_type_sync::<T>);
    mount_iface.pre_unmount = Some(mount_pre_unmount::<T>);
    mount_iface.remount = Some(mount_remount::<T>);
    mount_iface.remount_finish = Some(mount_remount_finish::<T>);
    mount_iface.unmount = Some(mount_unmount::<T>);
    mount_iface.unmount_finish = Some(mount_unmount_finish::<T>);
    mount_iface.unmount_with_operation = Some(mount_unmount_with_operation::<T>);
    mount_iface.unmount_with_operation_finish = Some(mount_unmount_with_operation_finish::<T>);
    mount_iface.unmounted = Some(mount_unmounted::<T>);
}

unsafe extern "C" fn mount_get_type<T: ObjectType>(
    type_: glib_ffi::GType
) -> glib::Type {
    callback_guard!();
    let klass = gobject_ffi::g_type_class_peek(type_);
    let klass = &*(klass as *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::mount_get_type()) as *const MountStatic<T>;
    (*(*interface_static).imp_static).get_type().to_glib()
}
