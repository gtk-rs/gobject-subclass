// This file was generated by gir (https://github.com/gtk-rs/gir @ a3d21e2+)
// from gir-files (https://github.com/gtk-rs/gir-files @ b215ee8+)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]

extern crate libc;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

use ffi;
use glib;
use glib::object::Downcast;
use glib::object::IsA;
use glib::signal::SignalHandlerId;
use glib::signal::connect;
use glib::translate::*;
use glib_ffi;
use gobject_ffi;
use libc;
use std::boxed::Box as Box_;
use std::mem;
use std::mem::transmute;
use std::ptr;


pub trait ActionGroupImpl: AnyImpl + 'static {

    fn action_added(&self, action_group: &T, action_name: &str);

    fn action_enabled_changed(&self, action_group: &T, action_name: &str, enabled: bool);

    fn action_removed(&self, action_group: &T, action_name: &str);

    fn action_state_changed(&self, action_group: &T, action_name: &str, state: &glib::Variant);

    fn activate_action(&self, action_group: &T, action_name: &str, parameter: Option<&glib::Variant>);

    fn change_action_state(&self, action_group: &T, action_name: &str, value: &glib::Variant);

    fn get_action_enabled(&self, action_group: &T, action_name: &str) -> bool;

    fn get_action_parameter_type(&self, action_group: &T, action_name: &str) -> Option<glib::VariantType>;

    fn get_action_state(&self, action_group: &T, action_name: &str) -> Option<glib::Variant>;

    fn get_action_state_hint(&self, action_group: &T, action_name: &str) -> Option<glib::Variant>;

    fn get_action_state_type(&self, action_group: &T, action_name: &str) -> Option<glib::VariantType>;

    fn has_action(&self, action_group: &T, action_name: &str) -> bool;

    fn list_actions(&self, action_group: &T) -> Vec<String>;

    fn query_action(&self, action_group: &T, action_name: &str) -> Option<(bool, glib::VariantType, glib::VariantType, glib::Variant, glib::Variant)>;

}

any_impl!(ActionGroupImpl);

pub trait ActionGroupImplStatic<T: ObjectType>: 'static {
    fn get_impl<'a>(&self, imp: &'a T::ImplType) -> &'a ActionGroupImpl;
}

struct ActionGroupStatic<T: ObjectType>{
    imp_static: *const ActionGroupImplStatic<T>
}

unsafe extern "C" fn actiongroup_action_added<T: >
(ptr: *mut GActionGroup, action_name: *const c_char)
where
    T::ImplType: ActionGroupImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::actiongroup_get_type())
                                     as *const ActionGroupStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.action_added()
}

unsafe extern "C" fn actiongroup_action_enabled_changed<T: >
(ptr: *mut GActionGroup, action_name: *const c_char, enabled: gboolean)
where
    T::ImplType: ActionGroupImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::actiongroup_get_type())
                                     as *const ActionGroupStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.action_enabled_changed()
}

unsafe extern "C" fn actiongroup_action_removed<T: >
(ptr: *mut GActionGroup, action_name: *const c_char)
where
    T::ImplType: ActionGroupImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::actiongroup_get_type())
                                     as *const ActionGroupStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.action_removed()
}

unsafe extern "C" fn actiongroup_action_state_changed<T: >
(ptr: *mut GActionGroup, action_name: *const c_char, state: *mut glib::GVariant)
where
    T::ImplType: ActionGroupImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::actiongroup_get_type())
                                     as *const ActionGroupStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.action_state_changed()
}

unsafe extern "C" fn actiongroup_activate_action<T: >
(ptr: *mut GActionGroup, action_name: *const c_char, parameter: *mut glib::GVariant)
where
    T::ImplType: ActionGroupImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::actiongroup_get_type())
                                     as *const ActionGroupStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.activate_action()
}

unsafe extern "C" fn actiongroup_change_action_state<T: >
(ptr: *mut GActionGroup, action_name: *const c_char, value: *mut glib::GVariant)
where
    T::ImplType: ActionGroupImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::actiongroup_get_type())
                                     as *const ActionGroupStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.change_action_state()
}

unsafe extern "C" fn actiongroup_get_action_enabled<T: >
(ptr: *mut GActionGroup, action_name: *const c_char) -> gboolean
where
    T::ImplType: ActionGroupImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::actiongroup_get_type())
                                     as *const ActionGroupStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_action_enabled()
}

unsafe extern "C" fn actiongroup_get_action_parameter_type<T: >
(ptr: *mut GActionGroup, action_name: *const c_char) -> *const glib::GVariantType
where
    T::ImplType: ActionGroupImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::actiongroup_get_type())
                                     as *const ActionGroupStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_action_parameter_type()
}

unsafe extern "C" fn actiongroup_get_action_state<T: >
(ptr: *mut GActionGroup, action_name: *const c_char) -> *mut glib::GVariant
where
    T::ImplType: ActionGroupImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::actiongroup_get_type())
                                     as *const ActionGroupStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_action_state()
}

unsafe extern "C" fn actiongroup_get_action_state_hint<T: >
(ptr: *mut GActionGroup, action_name: *const c_char) -> *mut glib::GVariant
where
    T::ImplType: ActionGroupImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::actiongroup_get_type())
                                     as *const ActionGroupStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_action_state_hint()
}

unsafe extern "C" fn actiongroup_get_action_state_type<T: >
(ptr: *mut GActionGroup, action_name: *const c_char) -> *const glib::GVariantType
where
    T::ImplType: ActionGroupImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::actiongroup_get_type())
                                     as *const ActionGroupStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_action_state_type()
}

unsafe extern "C" fn actiongroup_has_action<T: >
(ptr: *mut GActionGroup, action_name: *const c_char) -> gboolean
where
    T::ImplType: ActionGroupImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::actiongroup_get_type())
                                     as *const ActionGroupStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.has_action()
}

unsafe extern "C" fn actiongroup_list_actions<T: >
(ptr: *mut GActionGroup) -> *mut *mut c_char
where
    T::ImplType: ActionGroupImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::actiongroup_get_type())
                                     as *const ActionGroupStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.list_actions()
}

unsafe extern "C" fn actiongroup_query_action<T: >
(ptr: *mut GActionGroup, action_name: *const c_char, enabled: *mut gboolean, parameter_type: *mut *const glib::GVariantType, state_type: *mut *const glib::GVariantType, state_hint: *mut *mut glib::GVariant, state: *mut *mut glib::GVariant) -> gboolean
where
    T::ImplType: ActionGroupImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::actiongroup_get_type())
                                     as *const ActionGroupStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.query_action()
}

unsafe extern "C" fn actiongroup_init<T: ObjectType>(
    iface: glib_ffi::gpointer,
    iface_data: glib_ffi::gpointer
) {
    callback_guard!();
    let actiongroup_iface = &mut *(iface as *mut ffi::);
    let iface_type = (*(iface as *const gobject_ffi::GTypeInterface)).g_type;
    let type_ = (*(iface as *const gobject_ffi::GTypeInterface)).g_instance_type;
    let klass = &mut *(gobject_ffi::g_type_class_ref(type_) as *mut ClassStruct<T>);
    let interfaces_static = &mut *(klass.interfaces_static as *mut Vec<_>);
    interfaces_static.push((iface_type, iface_data))
    actiongroup_iface.action_added = Some(actiongroup_action_added::<T>);
    actiongroup_iface.action_enabled_changed = Some(actiongroup_action_enabled_changed::<T>);
    actiongroup_iface.action_removed = Some(actiongroup_action_removed::<T>);
    actiongroup_iface.action_state_changed = Some(actiongroup_action_state_changed::<T>);
    actiongroup_iface.activate_action = Some(actiongroup_activate_action::<T>);
    actiongroup_iface.change_action_state = Some(actiongroup_change_action_state::<T>);
    actiongroup_iface.get_action_enabled = Some(actiongroup_get_action_enabled::<T>);
    actiongroup_iface.get_action_parameter_type = Some(actiongroup_get_action_parameter_type::<T>);
    actiongroup_iface.get_action_state = Some(actiongroup_get_action_state::<T>);
    actiongroup_iface.get_action_state_hint = Some(actiongroup_get_action_state_hint::<T>);
    actiongroup_iface.get_action_state_type = Some(actiongroup_get_action_state_type::<T>);
    actiongroup_iface.has_action = Some(actiongroup_has_action::<T>);
    actiongroup_iface.list_actions = Some(actiongroup_list_actions::<T>);
    actiongroup_iface.query_action = Some(actiongroup_query_action::<T>);
}

unsafe extern "C" fn actiongroup_get_type<T: ObjectType>(
    type_: glib_ffi::GType
) -> glib::Type {
    callback_guard!();
    let klass = gobject_ffi::g_type_class_peek(type_);
    let klass = &*(klass as *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::actiongroup_get_type()) as *const ActionGroupStatic<T>;
    (*(*interface_static).imp_static).get_type().to_glib()
}
