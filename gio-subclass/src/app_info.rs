// This file was generated by gir (https://github.com/gtk-rs/gir @ a3d21e2+)
// from gir-files (https://github.com/gtk-rs/gir-files @ b215ee8+)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]

extern crate libc;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

use AppLaunchContext;
use Error;
use ffi;
use glib::object::IsA;
use glib::translate::*;
use glib_ffi;
use gobject_ffi;
use std;
use std::mem;
use std::ptr;


pub trait AppInfoImpl: AnyImpl + 'static {

    fn add_supports_type(&self, appinfo: &T, content_type: &str) -> Result<(), Error>;

    fn can_delete(&self, appinfo: &T) -> bool;

    fn can_remove_supports_type(&self, appinfo: &T) -> bool;

    fn do_delete(&self, appinfo: &T) -> bool;

    fn dup(&self, appinfo: &T) -> Option<AppInfo>;

    fn equal(&self, appinfo1: &T, appinfo2: &AppInfo) -> bool;

    fn get_commandline(&self, appinfo: &T) -> Option<String>;

    fn get_description(&self, appinfo: &T) -> Option<String>;

    fn get_display_name(&self, appinfo: &T) -> Option<String>;

    fn get_executable(&self, appinfo: &T) -> Option<String>;

    fn get_icon(&self, appinfo: &T) -> /*Ignored*/Option<Icon>;

    fn get_id(&self, appinfo: &T) -> Option<String>;

    fn get_name(&self, appinfo: &T) -> Option<String>;

    fn get_supported_types(&self, appinfo: &T) -> Vec<String>;

    fn launch(&self, appinfo: &T, files: /*Ignored*/&[File], context: Option<&AppLaunchContext>) -> Result<(), Error>;

    fn launch_uris(&self, appinfo: &T, uris: &[&str], context: Option<&AppLaunchContext>) -> Result<(), Error>;

    fn remove_supports_type(&self, appinfo: &T, content_type: &str) -> Result<(), Error>;

    fn set_as_default_for_extension(&self, appinfo: &T, extension: &std::path::Path) -> Result<(), Error>;

    fn set_as_default_for_type(&self, appinfo: &T, content_type: &str) -> Result<(), Error>;

    fn set_as_last_used_for_type(&self, appinfo: &T, content_type: &str) -> Result<(), Error>;

    fn should_show(&self, appinfo: &T) -> bool;

    fn supports_files(&self, appinfo: &T) -> bool;

    fn supports_uris(&self, appinfo: &T) -> bool;

}

any_impl!(AppInfoImpl);

pub trait AppInfoImplStatic<T: ObjectType>: 'static {
    fn get_impl<'a>(&self, imp: &'a T::ImplType) -> &'a AppInfoImpl;
}

struct AppInfoStatic<T: ObjectType>{
    imp_static: *const AppInfoImplStatic<T>
}

unsafe extern "C" fn appinfo_add_supports_type<T: >
(ptr: *mut GAppInfo, content_type: *const c_char, error: *mut *mut glib::GError) -> gboolean
where
    T::ImplType: AppInfoImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type())
                                     as *const AppInfoStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.add_supports_type()
}

unsafe extern "C" fn appinfo_can_delete<T: >
(ptr: *mut GAppInfo) -> gboolean
where
    T::ImplType: AppInfoImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type())
                                     as *const AppInfoStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.can_delete()
}

unsafe extern "C" fn appinfo_can_remove_supports_type<T: >
(ptr: *mut GAppInfo) -> gboolean
where
    T::ImplType: AppInfoImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type())
                                     as *const AppInfoStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.can_remove_supports_type()
}

unsafe extern "C" fn appinfo_do_delete<T: >
(ptr: *mut GAppInfo) -> gboolean
where
    T::ImplType: AppInfoImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type())
                                     as *const AppInfoStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.do_delete()
}

unsafe extern "C" fn appinfo_dup<T: >
(ptr: *mut GAppInfo) -> *mut GAppInfo
where
    T::ImplType: AppInfoImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type())
                                     as *const AppInfoStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.dup()
}

unsafe extern "C" fn appinfo_equal<T: >
(ptr: *mut GAppInfo, appinfo2: *mut GAppInfo) -> gboolean
where
    T::ImplType: AppInfoImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type())
                                     as *const AppInfoStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.equal()
}

unsafe extern "C" fn appinfo_get_commandline<T: >
(ptr: *mut GAppInfo) -> *const c_char
where
    T::ImplType: AppInfoImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type())
                                     as *const AppInfoStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_commandline()
}

unsafe extern "C" fn appinfo_get_description<T: >
(ptr: *mut GAppInfo) -> *const c_char
where
    T::ImplType: AppInfoImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type())
                                     as *const AppInfoStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_description()
}

unsafe extern "C" fn appinfo_get_display_name<T: >
(ptr: *mut GAppInfo) -> *const c_char
where
    T::ImplType: AppInfoImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type())
                                     as *const AppInfoStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_display_name()
}

unsafe extern "C" fn appinfo_get_executable<T: >
(ptr: *mut GAppInfo) -> *const c_char
where
    T::ImplType: AppInfoImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type())
                                     as *const AppInfoStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_executable()
}

unsafe extern "C" fn appinfo_get_icon<T: >
(ptr: *mut GAppInfo) -> *mut GIcon
where
    T::ImplType: AppInfoImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type())
                                     as *const AppInfoStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_icon()
}

unsafe extern "C" fn appinfo_get_id<T: >
(ptr: *mut GAppInfo) -> *const c_char
where
    T::ImplType: AppInfoImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type())
                                     as *const AppInfoStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_id()
}

unsafe extern "C" fn appinfo_get_name<T: >
(ptr: *mut GAppInfo) -> *const c_char
where
    T::ImplType: AppInfoImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type())
                                     as *const AppInfoStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_name()
}

unsafe extern "C" fn appinfo_get_supported_types<T: >
(ptr: *mut GAppInfo) -> *mut *mut c_char
where
    T::ImplType: AppInfoImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type())
                                     as *const AppInfoStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.get_supported_types()
}

unsafe extern "C" fn appinfo_launch<T: >
(ptr: *mut GAppInfo, files: *mut glib::GList, context: *mut GAppLaunchContext, error: *mut *mut glib::GError) -> gboolean
where
    T::ImplType: AppInfoImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type())
                                     as *const AppInfoStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.launch()
}

unsafe extern "C" fn appinfo_launch_uris<T: >
(ptr: *mut GAppInfo, uris: *mut glib::GList, context: *mut GAppLaunchContext, error: *mut *mut glib::GError) -> gboolean
where
    T::ImplType: AppInfoImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type())
                                     as *const AppInfoStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.launch_uris()
}

unsafe extern "C" fn appinfo_remove_supports_type<T: >
(ptr: *mut GAppInfo, content_type: *const c_char, error: *mut *mut glib::GError) -> gboolean
where
    T::ImplType: AppInfoImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type())
                                     as *const AppInfoStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.remove_supports_type()
}

unsafe extern "C" fn appinfo_set_as_default_for_extension<T: >
(ptr: *mut GAppInfo, extension: *const c_char, error: *mut *mut glib::GError) -> gboolean
where
    T::ImplType: AppInfoImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type())
                                     as *const AppInfoStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.set_as_default_for_extension()
}

unsafe extern "C" fn appinfo_set_as_default_for_type<T: >
(ptr: *mut GAppInfo, content_type: *const c_char, error: *mut *mut glib::GError) -> gboolean
where
    T::ImplType: AppInfoImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type())
                                     as *const AppInfoStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.set_as_default_for_type()
}

unsafe extern "C" fn appinfo_set_as_last_used_for_type<T: >
(ptr: *mut GAppInfo, content_type: *const c_char, error: *mut *mut glib::GError) -> gboolean
where
    T::ImplType: AppInfoImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type())
                                     as *const AppInfoStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.set_as_last_used_for_type()
}

unsafe extern "C" fn appinfo_should_show<T: >
(ptr: *mut GAppInfo) -> gboolean
where
    T::ImplType: AppInfoImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type())
                                     as *const AppInfoStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.should_show()
}

unsafe extern "C" fn appinfo_supports_files<T: >
(ptr: *mut GAppInfo) -> gboolean
where
    T::ImplType: AppInfoImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type())
                                     as *const AppInfoStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.supports_files()
}

unsafe extern "C" fn appinfo_supports_uris<T: >
(ptr: *mut GAppInfo) -> gboolean
where
    T::ImplType: AppInfoImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let klass = &**(ptr as *const *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type())
                                     as *const AppInfoStatic<T>;
    let interface_static = &*(ptr as *const T::InstanceStructType);
    let imp = instance.get_impl();
    let imp = (*(*interface_static).imp_static).get_impl(imp);
    imp.supports_uris()
}

unsafe extern "C" fn appinfo_init<T: ObjectType>(
    iface: glib_ffi::gpointer,
    iface_data: glib_ffi::gpointer
) {
    callback_guard!();
    let appinfo_iface = &mut *(iface as *mut ffi::);
    let iface_type = (*(iface as *const gobject_ffi::GTypeInterface)).g_type;
    let type_ = (*(iface as *const gobject_ffi::GTypeInterface)).g_instance_type;
    let klass = &mut *(gobject_ffi::g_type_class_ref(type_) as *mut ClassStruct<T>);
    let interfaces_static = &mut *(klass.interfaces_static as *mut Vec<_>);
    interfaces_static.push((iface_type, iface_data))
    appinfo_iface.add_supports_type = Some(appinfo_add_supports_type::<T>);
    appinfo_iface.can_delete = Some(appinfo_can_delete::<T>);
    appinfo_iface.can_remove_supports_type = Some(appinfo_can_remove_supports_type::<T>);
    appinfo_iface.do_delete = Some(appinfo_do_delete::<T>);
    appinfo_iface.dup = Some(appinfo_dup::<T>);
    appinfo_iface.equal = Some(appinfo_equal::<T>);
    appinfo_iface.get_commandline = Some(appinfo_get_commandline::<T>);
    appinfo_iface.get_description = Some(appinfo_get_description::<T>);
    appinfo_iface.get_display_name = Some(appinfo_get_display_name::<T>);
    appinfo_iface.get_executable = Some(appinfo_get_executable::<T>);
    appinfo_iface.get_icon = Some(appinfo_get_icon::<T>);
    appinfo_iface.get_id = Some(appinfo_get_id::<T>);
    appinfo_iface.get_name = Some(appinfo_get_name::<T>);
    appinfo_iface.get_supported_types = Some(appinfo_get_supported_types::<T>);
    appinfo_iface.launch = Some(appinfo_launch::<T>);
    appinfo_iface.launch_uris = Some(appinfo_launch_uris::<T>);
    appinfo_iface.remove_supports_type = Some(appinfo_remove_supports_type::<T>);
    appinfo_iface.set_as_default_for_extension = Some(appinfo_set_as_default_for_extension::<T>);
    appinfo_iface.set_as_default_for_type = Some(appinfo_set_as_default_for_type::<T>);
    appinfo_iface.set_as_last_used_for_type = Some(appinfo_set_as_last_used_for_type::<T>);
    appinfo_iface.should_show = Some(appinfo_should_show::<T>);
    appinfo_iface.supports_files = Some(appinfo_supports_files::<T>);
    appinfo_iface.supports_uris = Some(appinfo_supports_uris::<T>);
}

unsafe extern "C" fn appinfo_get_type<T: ObjectType>(
    type_: glib_ffi::GType
) -> glib::Type {
    callback_guard!();
    let klass = gobject_ffi::g_type_class_peek(type_);
    let klass = &*(klass as *const ClassStruct<T>);
    let interface_static = klass.get_interface_static(ffi::appinfo_get_type()) as *const AppInfoStatic<T>;
    (*(*interface_static).imp_static).get_type().to_glib()
}
