// This file was generated by gir (https://github.com/gtk-rs/gir @ a3d21e2+)
// from gir-files (https://github.com/gtk-rs/gir-files @ b215ee8+)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]

extern crate libc;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

use ffi;
use glib;
use glib::object::Downcast;
use glib::object::IsA;
use glib::signal::SignalHandlerId;
use glib::signal::connect;
use glib::translate::*;
use glib_ffi;
use gobject_ffi;
use std::boxed::Box as Box_;
use std::mem;
use std::mem::transmute;
use std::ptr;


pub trait PermissionImpl<T: PermissionBase>: ObjectImpl<T> + AnyImpl + 'static {

    fn acquire(&self, permission: &T, cancellable: /*Ignored*/Option<&Cancellable>) -> Result<(), Error>{
        permission.parent_acquire(cancellable)
    }

    fn acquire_async(&self, permission: &T, cancellable: /*Ignored*/Option<&Cancellable>, callback: AsyncReadyCallback){
        permission.parent_acquire_async(cancellable, callback)
    }

    fn acquire_finish(&self, permission: &T, result: /*Ignored*/&AsyncResult) -> Result<(), Error>{
        permission.parent_acquire_finish(result)
    }

    fn release(&self, permission: &T, cancellable: /*Ignored*/Option<&Cancellable>) -> Result<(), Error>{
        permission.parent_release(cancellable)
    }

    fn release_async(&self, permission: &T, cancellable: /*Ignored*/Option<&Cancellable>, callback: AsyncReadyCallback){
        permission.parent_release_async(cancellable, callback)
    }

    fn release_finish(&self, permission: &T, result: /*Ignored*/&AsyncResult) -> Result<(), Error>{
        permission.parent_release_finish(result)
    }

}

pub trait PermissionImplExt<T> {}

}
impl<S: PermissionImpl<T>, T: ObjectType >> PermissionImplExt<T> for S {}

any_impl!(PermissionBase, PermissionImpl);

pub unsafe trait PermissionBase: ObjectType {

    fn parent_acquire(&self, cancellable: /*Ignored*/Option<&Cancellable>) -> Result<(), Error>{
        let cancellable = cancellable.into();
        let cancellable = cancellable.to_glib_none();
        unsafe {
            let klass = self.get_class();
            let parent_klass = (*klass).get_parent_class() as *const ffi::GPermissionClass;
            (*parent_klass)
            .acquire
            .map(|f|{ let mut error = ptr::null_mut(); let _ = f(self.to_glib_none().0,cancellable.0,error.to_glib_full()); if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) } })
            .unwrap_or(())
        }
    }

    fn parent_acquire_async(&self, cancellable: /*Ignored*/Option<&Cancellable>, callback: AsyncReadyCallback){
        let cancellable = cancellable.into();
        let cancellable = cancellable.to_glib_none();
        unsafe {
            let klass = self.get_class();
            let parent_klass = (*klass).get_parent_class() as *const ffi::GPermissionClass;
            (*parent_klass)
            .acquire_async
            .map(|f|{ f(self.to_glib_none().0,cancellable.0,Some(callback),Box::into_raw(user_data) as *mut _); })
            .unwrap_or(())
        }
    }

    fn parent_acquire_finish(&self, result: /*Ignored*/&AsyncResult) -> Result<(), Error>{
        unsafe {
            let klass = self.get_class();
            let parent_klass = (*klass).get_parent_class() as *const ffi::GPermissionClass;
            (*parent_klass)
            .acquire_finish
            .map(|f|{ let mut error = ptr::null_mut(); let _ = f(self.to_glib_none().0,result.to_glib_none().0,error.to_glib_full()); if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) } })
            .unwrap_or(())
        }
    }

    fn parent_release(&self, cancellable: /*Ignored*/Option<&Cancellable>) -> Result<(), Error>{
        let cancellable = cancellable.into();
        let cancellable = cancellable.to_glib_none();
        unsafe {
            let klass = self.get_class();
            let parent_klass = (*klass).get_parent_class() as *const ffi::GPermissionClass;
            (*parent_klass)
            .release
            .map(|f|{ let mut error = ptr::null_mut(); let _ = f(self.to_glib_none().0,cancellable.0,error.to_glib_full()); if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) } })
            .unwrap_or(())
        }
    }

    fn parent_release_async(&self, cancellable: /*Ignored*/Option<&Cancellable>, callback: AsyncReadyCallback){
        let cancellable = cancellable.into();
        let cancellable = cancellable.to_glib_none();
        unsafe {
            let klass = self.get_class();
            let parent_klass = (*klass).get_parent_class() as *const ffi::GPermissionClass;
            (*parent_klass)
            .release_async
            .map(|f|{ f(self.to_glib_none().0,cancellable.0,Some(callback),Box::into_raw(user_data) as *mut _); })
            .unwrap_or(())
        }
    }

    fn parent_release_finish(&self, result: /*Ignored*/&AsyncResult) -> Result<(), Error>{
        unsafe {
            let klass = self.get_class();
            let parent_klass = (*klass).get_parent_class() as *const ffi::GPermissionClass;
            (*parent_klass)
            .release_finish
            .map(|f|{ let mut error = ptr::null_mut(); let _ = f(self.to_glib_none().0,result.to_glib_none().0,error.to_glib_full()); if error.is_null() { Ok(()) } else { Err(from_glib_full(error)) } })
            .unwrap_or(())
        }
    }

}

pub unsafe trait PermissionClassExt<T: PermissionBase>
where
    T::ImplType: PermissionImpl<T>{

    fn override_vfuncs(&mut self, _: &ClassInitToken){
        unsafe {
            let klass = &mut *(self as *const Self as *mut ffi::GPermissionClass);
            klass.acquire = Some(permission_acquire::<T>);
            klass.acquire_async = Some(permission_acquire_async::<T>);
            klass.acquire_finish = Some(permission_acquire_finish::<T>);
            klass.release = Some(permission_release::<T>);
            klass.release_async = Some(permission_release_async::<T>);
            klass.release_finish = Some(permission_release_finish::<T>);
        }
    }

}

glib_wrapper! {

    pub struct Permission(Object<InstanceStruct<Permission>>)    ;
    match fn { 
         get_type => || get_type::<Permission>(),
     }

}

unsafe impl<T: ObjectType > PermissionBase for T {}

pub type PermissionClass = ClassStruct<Permission>;

// FIXME: Boilerplate

// FIXME: Boilerplate

#[macro_export]
macro_rules! box_permission_impl(
    ($name:ident) => {
        box_object_impl!($name);
        impl<T: $crate::permission::PermissionBase> $crate::permission::PermissionImpl<T> for Box<$name<T>>{

            fn acquire(&self, permission: &T, cancellable: /*Ignored*/Option<&Cancellable>) -> Result<(), Error>{
                let imp: &$name<T> = self.as_ref();
                imp.acquire(cancellable)
            }

            fn acquire_async(&self, permission: &T, cancellable: /*Ignored*/Option<&Cancellable>, callback: AsyncReadyCallback){
                let imp: &$name<T> = self.as_ref();
                imp.acquire_async(cancellable, callback)
            }

            fn acquire_finish(&self, permission: &T, result: /*Ignored*/&AsyncResult) -> Result<(), Error>{
                let imp: &$name<T> = self.as_ref();
                imp.acquire_finish(result)
            }

            fn release(&self, permission: &T, cancellable: /*Ignored*/Option<&Cancellable>) -> Result<(), Error>{
                let imp: &$name<T> = self.as_ref();
                imp.release(cancellable)
            }

            fn release_async(&self, permission: &T, cancellable: /*Ignored*/Option<&Cancellable>, callback: AsyncReadyCallback){
                let imp: &$name<T> = self.as_ref();
                imp.release_async(cancellable, callback)
            }

            fn release_finish(&self, permission: &T, result: /*Ignored*/&AsyncResult) -> Result<(), Error>{
                let imp: &$name<T> = self.as_ref();
                imp.release_finish(result)
            }
        }
    }
);

impl ObjectType for Permission{
    const NAME: &'static str = "RsGio.Permission";
    type ImplType = Box<PermissionImpl<Self>>;
    type InstanceStructType = InstanceStruct<Self>;
    fn class_init(token: &ClassInitToken, klass: &mut PermissionClass) {
        ObjectClassExt::override_vfuncs(klass, token);
    }
    object_type_fns!();
}

unsafe extern "C" fn permission_acquire<T: PermissionBase>
(ptr: *mut GPermission, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean
where
    T::ImplType: PermissionImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let permission = &*(ptr as *mut T::InstanceStructType);
    let wrap: T = from_glib_borrow(ptr as *mut T::InstanceStructType);
    let imp = permission.get_impl();
    imp.acquire()
}

unsafe extern "C" fn permission_acquire_async<T: PermissionBase>
(ptr: *mut GPermission, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer)
where
    T::ImplType: PermissionImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let permission = &*(ptr as *mut T::InstanceStructType);
    let wrap: T = from_glib_borrow(ptr as *mut T::InstanceStructType);
    let imp = permission.get_impl();
    imp.acquire_async()
}

unsafe extern "C" fn permission_acquire_finish<T: PermissionBase>
(ptr: *mut GPermission, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean
where
    T::ImplType: PermissionImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let permission = &*(ptr as *mut T::InstanceStructType);
    let wrap: T = from_glib_borrow(ptr as *mut T::InstanceStructType);
    let imp = permission.get_impl();
    imp.acquire_finish()
}

unsafe extern "C" fn permission_release<T: PermissionBase>
(ptr: *mut GPermission, cancellable: *mut GCancellable, error: *mut *mut glib::GError) -> gboolean
where
    T::ImplType: PermissionImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let permission = &*(ptr as *mut T::InstanceStructType);
    let wrap: T = from_glib_borrow(ptr as *mut T::InstanceStructType);
    let imp = permission.get_impl();
    imp.release()
}

unsafe extern "C" fn permission_release_async<T: PermissionBase>
(ptr: *mut GPermission, cancellable: *mut GCancellable, callback: GAsyncReadyCallback, user_data: gpointer)
where
    T::ImplType: PermissionImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let permission = &*(ptr as *mut T::InstanceStructType);
    let wrap: T = from_glib_borrow(ptr as *mut T::InstanceStructType);
    let imp = permission.get_impl();
    imp.release_async()
}

unsafe extern "C" fn permission_release_finish<T: PermissionBase>
(ptr: *mut GPermission, result: *mut GAsyncResult, error: *mut *mut glib::GError) -> gboolean
where
    T::ImplType: PermissionImpl<T>
{
    callback_guard!();
    floating_reference_guard!(ptr);
    let permission = &*(ptr as *mut T::InstanceStructType);
    let wrap: T = from_glib_borrow(ptr as *mut T::InstanceStructType);
    let imp = permission.get_impl();
    imp.release_finish()
}
